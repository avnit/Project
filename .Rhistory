source('~/Downloads/demoData-2.R')
require(TTR)
require(quantmod)
require(PerformanceAnalytics)
require(quantstrat)
source('~/Project/R/demoData-2.R')
install.packages("quantstrat", repos="http://R-Forge.R-project.org")
packrat::disable()
source('~/Project/R/demoData-2.R')
MyData <- read.csv(file = "holdings-xlk.csv", header = TRUE, sep = ",")
source('~/Project/R/demoData-2.R')
getSymbols("ANRI")
getSymbols(ANRI)
symbols <- c("HSY","MDLZ",
"RMCF",
"TR" )
initDate = "2001-01-01"
from="2013-01-01"
to = "2016-01-01"
# download all the data
if ( !"AAPL" %in% ls())
{
#if data is not in the enviornment then get it from Yahoo getSymbol
suppressMessages(
getSymbols(
symbols,from = from, to = to,src = "google"
)
}
stock(symbols,currency = "USD",multiplier = 1)
CCINew <- function(x,n = 10,...)
{
# print(x[,6])
y <- TTR::CCI(x,n = n,...)
out<-y$CCI
#  print(y)
#print(head(out))
out[is.na(out)] <- x[is.na(out)]
colnames(out) <- "cci"
return(out)
}
source('~/Class1/ProjectStart.R')
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SPUX","KHC",
"MDLC","SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SPUX","KHC",
"MDLC","SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB"
)
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"MDLC","SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB"
)
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB"
)
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN","JAMBA"
)
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
lenght(stock.str)
length(stock.str)
,
source('~/Class1/ProjectStart.R')
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN","JMBA","MNST","FIZZ",
"JJSF","INGR","RMCF"
)
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN","JMBA","MNST","FIZZ",
"JJSF","INGR","RMCF","WWY","WWAV","FDP"
)
if (!"HSY" %in% ls())
{
#if data is not in the enviornment then get it from Yahoo getSymbol
suppressMessages(
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
}
View(BGS)
as.data.frame(Quandl("FRED/M04031US35620M267NNBR")) -> matrix
install.packages("devtools")
library(devtools)
install_github('quandl/R-package')
library(Quandl)
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN","JMBA","MNST","FIZZ",
"JJSF","INGR","RMCF","WWY","WWAV","FDP","YUM"
)
suppressMessages(
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
source('~/Class1/ProjectStart.R')
install.packages("devtools")
as.data.frame(Quandl("FRED/M04031US35620M267NNBR")) -> matrix
as.data.frame(Quandl("FRED/M04031US35620M267NNBR"))
library(Quandl)
Quandl()
Quandl("FRED/M04031US35620M267NNBR")
source('~/Class1/ProjectStart.R')
as.data.frame(Quandl("FRED/M04031US35620M267NNBR")) -> matrix
stock.str <-  c("HSY","MDLZ", "RMCF", "TR","KO","PEP","SODA","DPS","CAG","GIS","SBUX","KHC",
"SJM","CCE","UN","DF","SYUT","DNKN","MCD","RRGB","TSN","CPB","TR","HRL","MKC",
"LANC","BGS","LNCE","JBSS","PF","KKD","SONC","JACK","WEN","JMBA","MNST","FIZZ",
"JJSF","INGR","RMCF","WWAV","FDP","YUM","CBO","DENN","POST"
)
suppressMessages(
getSymbols(
stock.str,from = from, to = to, index.class = c('POSIXt','POSIXct'),env =
globalenv(),src = "google"
)
matrix
zoo
source('~/Project/R/InSampleTesting.R', echo=TRUE)
pairs(coredata(rM))
rM
pairs(coredata(rM))
#compute the covariance matrix
covR <- cov(rM)
#use this covariance matrix to simulate normal random numbers
#that share a similar correlation structure with the actual data
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
p0 <- apply(pM,2,mean)
sPL <- list()
for(i in 1:ncol(rM)){
sPL[[i]] <-round(p0[i]*exp(cumsum(rV[,i])),2)
}
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
#plot simulated prices
for ( i in 1:length(sPL))
{
plot(sPL[[i]],main="output" + 1,type="l")
}
covR <- cov(na.omit(rM))
pairs(coredata(na.omit(rM))
)
rM
head(rM)
MNST
PF
class(pM)
pM
head(pM)
#compute returns matrix
rM <-  apply(na.omit(pM),2,function(x) diff(log(x)))
rM <-  apply(pM,2,function(x) diff(log(na.omit(x)))
)
pairs(coredata(na.omit(rM))
)
rM
rM <-  apply(pM,2,function(x) diff(log(x)))
pairs(coredata(na.omit(rM)))
surpressWarnings(pairs(coredata(na.omit(rM))))
suppressMessages(pairs(coredata(na.omit(rM))))
tryCatch({(pairs(coredata(na.omit(rM))))
#compute the covariance matrix
covR <- cov(na.omit(rM))
#use this covariance matrix to simulate normal random numbers
#that share a similar correlation structure with the actual data
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
#simulate prices based on these correlated random variables
#calculate mean price
p0 <- apply(pM,2,mean)
sPL <- list()
for(i in 1:ncol(rM)){
sPL[[i]] <-round(p0[i]*exp(cumsum(rV[,i])),2)
}
# create Graph in the Plot area
# can use Rcpp function that we created noofrow = ElvisOperator(length(sPL) %% 2 == 0) ,
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
#plot simulated prices
for ( i in 1:length(sPL))
{
plot(sPL[[i]],main="output" + 1,type="l")
}
},error=function(e){print(e)})
}
#pairs(coredata(na.omit(rM))))
tryCatch({
#pairs(coredata(na.omit(rM))))
#compute the covariance matrix
covR <- cov(na.omit(rM))
#use this covariance matrix to simulate normal random numbers
#that share a similar correlation structure with the actual data
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
#simulate prices based on these correlated random variables
#calculate mean price
p0 <- apply(pM,2,mean)
sPL <- list()
for(i in 1:ncol(rM)){
sPL[[i]] <-round(p0[i]*exp(cumsum(rV[,i])),2)
}
# create Graph in the Plot area
# can use Rcpp function that we created noofrow = ElvisOperator(length(sPL) %% 2 == 0) ,
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
#plot simulated prices
for ( i in 1:length(sPL))
{
plot(sPL[[i]],main="output" + 1,type="l")
}
},error=function(e){print(e)})
}
tryCatch({
#pairs(coredata(na.omit(rM))))
#compute the covariance matrix
covR <- cov(na.omit(rM))
#use this covariance matrix to simulate normal random numbers
#that share a similar correlation structure with the actual data
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
#simulate prices based on these correlated random variables
#calculate mean price
p0 <- apply(pM,2,mean)
sPL <- list()
for(i in 1:ncol(rM)){
sPL[[i]] <-round(p0[i]*exp(cumsum(rV[,i])),2)
}
# create Graph in the Plot area
# can use Rcpp function that we created noofrow = ElvisOperator(length(sPL) %% 2 == 0) ,
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
#plot simulated prices
for ( i in 1:length(sPL))
{
plot(sPL[[i]],main="output" + 1,type="l")
}
},error=function(e){print(e)})
covR <- cov(na.omit(rM))
covR
covR <- cov(rM)
covR
data<-mget(my.df.names)
pM<-na.omit(data[[1]][,4])
for(i in seq(2,length(data)))
{
pM<-cbind(pM,(data[[i]][,4])
}
pM<-na.omit(data[[1]][,4])
for(i in seq(2,length(data)))
{
pM<-cbind(pM,data[[i]][,4])
}
rM <-  apply(pM,2,function(x) diff(log(x)))
pairs(coredata(na.omit(rM))))
pairs(coredata(rM))
covR <- cov(rM)
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
meanV
rV
covR
rV    <- mvrnorm(n = nrow(na.omit(rM)), mu = meanV, Sigma = covR)
pairs(coredata(na.omit(rM)))
rM
rM[is.na(rM)] <- 0
pairs(coredata(rM))
rM
covR <- cov(rM)
cvoR
covR
meanV <- apply(rM, 2, mean)
rV    <- mvrnorm(n = nrow(rM), mu = meanV, Sigma = covR)
p0 <- apply(pM,2,mean)
sPL <- list()
for(i in 1:ncol(rM)){
sPL[[i]] <-round(p0[i]*exp(cumsum(rV[,i])),2)
}
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
#plot simulated prices
for ( i in 1:length(sPL))
{
plot(sPL[[i]],main="output" + 1,type="l")
}
noofrow
par (mfrow = c(noofrow , 2))
plot(sPL[[1]],main="output" + 1,type="l")
sPL[[1]]
ggplot(sPL[[1]],main="output" + 1,type="l")
ggplot2(sPL[[1]],main="output" + 1,type="l")
ggplot2::ggplot_gtable(sPL[[1]])
ggplot2::aes(sPL[[1]])
ggplot2(sPL[[1]],main="output" + 1,type="l")
plot(sPL[[1]],main="output" + 1,type="l")
par(mar = rep(2, 4))
pairs(coredata(rM))
dev.set()
pairs(coredata(rM))
for ( i in 1:length(sPL))
{
# plot only works in big screen
plot(sPL[[i]],main="output" + 1,type="l")
}
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
for ( i in 1:length(sPL))
{
# plot only works in big screen
plot(sPL[[i]],main="output" + 1,type="l")
}
dev.set()
noofrow <- if(length(sPL) %% 2 == 0 ) length(sPL)/2  else length(sPL)/2 + 1
par (mfrow = c(noofrow , 2))
for ( i in 1:length(sPL))
{
# plot only works in big screen
plot(sPL[[i]],main="output" + 1,type="l")
}
par(mar = rep(2, 4))
for ( i in 1:length(sPL))
{
# plot only works in big screen
plot(sPL[[i]],main="output" + 1,type="l")
}
spL[[1]]
sPL[[1]]
max(sPL)
max(sPL[[1]])
min(sPL[[1]])
